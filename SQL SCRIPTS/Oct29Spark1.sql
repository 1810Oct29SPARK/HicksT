 
--SCRIPTS OFTEN BEGIN WITH DROP STATEMENTS TO AVOID NAMING CLASHES
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY(BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);
/
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY(CAVE_ID) REFERENCES CAVE(CAVE_ID);
/

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEAR_BEEHIVE
FOREIGN KEY(BEAR_ID) REFERENCES BEAR(BEAR_ID);
/
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEEHHIVE_BEAR_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/
--ADD SOME DATA
--TWO DIFERENCT WAYS TO INSERT: BY FILLING ALL COLUMNS OR SPECIFYING WHICH COLUMNS TO FILL
INSERT INTO BEAR_TYPE VALUES(1, 'Grizzly');
INSERT INTO BEAR_TYPE ( BEAR_TYPE_ID, BEAR_TYPE_NAME) VALUES (2,'Polar');

INSERT ALL
INTO CAVE 
VALUES (1, 'AWESOMECAVE1', 9)
INTO CAVE(CAVE_ID, CAVE_NAME)
VALUES (2, 'Tampa')
SELECT * FROM DUAL; -- DUAL IS A DUMMY TABLE

INSERT ALL 
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES( 72, 'Barry', TO_DATE ('1987-08-18 00:00:00','yyyy-mm-dd hh24:mi:ss'), 1, 2) 
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES( 891, 'Tim', TO_DATE ('1902-08-18 00:00:00','yyyy-mm-dd hh24:mi:ss'), 1, 1)
INTO BEAR
VALUES( 12, 'Walter', TO_DATE ('1901-12-05 00:00:00','yyyy-mm-dd hh24:mi:ss'), 800.00, 1, 2)
INTO BEAR
VALUES( 53, 'Brother', TO_DATE ('1995-11-11 13:09:00','yyyy-mm-dd hh24:mi:ss'), 100.00, 2, 2)
SELECT * FROM DUAL;

INSERT ALL 
INTO BEEHIVE
VALUES (1,30)
INTO BEEHIVE (BEEHIVE_ID)
VALUES (2)
INTO BEAR_BEEHIVE
VALUES (891, 1)
INTO BEAR_BEEHIVE
VALUES (891, 2)
INTO BEAR_BEEHIVE
VALUES (12, 2)
SELECT * FROM DUAL;


-- SELECT STATEMENT
SELECT * FROM BEAR;

SELECT BEAR_NAME, BIRTHDATE, WEIGHT
FROM BEAR
WHERE CAVE_ID = 2;


SELECT CAVE_ID FROM BEAR
GROUP BY CAVE_ID; --JUST THE DISTINCT CAVE_ID VALUES

SELECT AVG(WEIGHT), CAVE_ID FROM BEAR
GROUP BY CAVE_ID
HAVING AVG(WEIGHT) > 300;

CREATE SEQUENCE SQ_BEAR_PK
start with 1000
increment by 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
start with 1000
increment by 1;
/
CREATE SEQUENCE SQ_CAVE_PK
start with 1000
increment by 1;
/
CREATE SEQUENCE SQ_BEEHIVE_PK
start with 1000
increment by 1;/

create or replace TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;   
/
create or replace TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
create or replace TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/
create or replace TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE --SPECIFY WHICH DML OPERATION, BEFORE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
END; 

INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('Bruce', TO_DATE('1999,04,04 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 2, 150);
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('Betty', TO_DATE('1999,04,04 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 2, 900);


--GIVE BRUCE AND BETTY SOMEWHERE TO LIVE
UPDATE BEAR SET CAVE_ID = 1
WHERE BIRTHDATE = '04-APR-99';


--JOINS!
--ADD A CAVELESS BEAER
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID)
VALUES('Winifred', TO_DATE('1999,03,04 00:00:00', 'yyyy-mm-dd hh24:mi:ss'), 2);

INSERT INTO CAVE(CAVE_NAME)
VALUES('Philadelphia');


--SHOW CAVE DETAILS FOR EACH BEAR

--LEFT JOINS! 
SELECT * 
FROM BEAR B --ALIAS BEAR TABLE
LEFT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID; -- NO PHILADELPHIA

SELECT * 
FROM BEAR B --ALIAS BEAR TABLE
RIGHT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID; --NO WINIFRED

SELECT * 
FROM BEAR B --ALIAS BEAR TABLE
FULL JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID; --NO WINIFRED

--FILTER OUT COLUMNS, ALIAS COLUMN NAMES IN RESULT SET
SELECT B.BEAR_NAME, B.BIRTHDATE AS BEARTHDATE, CAVE.CAVE_NAME 
FROM BEAR B --ALIAS BEAR TABLE
LEFT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID; --NO WINIFRED/

--DISSPLAY CAVES IN WHICH AVERAGE AGE OF BEARS > 20
--OCCUPIED CAVES
SELECT B.CAVE_ID, CAVE.CAVE_NAME
FROM BEAR B
INNER JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID
GROUP BY B.CAVE_ID, CAVE.CAVE_NAME;



SELECT B.CAVE_ID, CAVE.CAVE_NAME, AVG(TO_NUMBER(TO_CHAR(B.BIRTHDATE, 'yyyymmddhh24miss')))
FROM BEAR B
INNER JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID
GROUP BY B.CAVE_ID, CAVE.CAVE_NAME;



--views 
CREATE VIEW VW_CAVE_BEAR_WEIGHT(CAVE, AVGBEARWEIGHT)
AS
SELECT CAVE_NAME, AVG(BEAR_WEIGHT)
FROM CAVE
LEFT JOIN BEAR ON CAVE_ID = BEAR.CAVE_ID
GROUP BY CAVE_NAME;

SELECT* FROM VW_CAVE_BEAR_WEIGHT;

CREATE VIEW VE_BEARS_PER_CAVE(CAVE, NUMBEAR)
AS
SELECT CAVE_NAME, COUNT(BEAR_ID) --SYSTEM-DEFINED AGGREGATE FUNCTION
FROM BEAR, CAVE
WHERE BEAR.CAVE_ID = CAVE.CAVE_ID
GROUP BY CAVE_NAME;

SELECT * FROM VE_BEARS_PER_CAVE;

UPDATE BEAR SET CAVE_ID = 1000 WHERE BEAR_NAME = 'Winifred';


--user-defined functions
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER(X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    IF X > Y THEN
    Z := X; --PL/SQL ASSIGNMENT OPERATOR
    ELSE
    Z := Y;
    END IF;
    RETURN Z;
END;

--CALL OUR FUNCTION!
DECLARE
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
    FIRST_NUM := 22;
    SECOND_NUM :=42;
    MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM);
END;

--CURSOR: POINTER TO THE 'ACTIVE SET'
--MOVE THROUGH RESULT SET USING CURSORS

--
--DIDNT WORK 
--
CREATE OR REPLACE FUNCTION PRINT_ALL_BEARS
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR
    SELECT BEAR_ID, BEAR_NAME FROM BEAR;
    RETURN S;
END;

DECLARE
S SYS_REFCURSOR;

SOME_ID BEAR.BEAR_ID%TYPE; --DECLARES SOME ID AS WHATEVER TYPE BEAR.BEAR_ID IS
SOME_NAME BEAR.BEAR_NAME%TYPE;
BEGIN 
    S := PRINT_ALL_BEARS;
    LOOP
        FETCH S INTO SOME_ID, SOME_NAME;
        EXIT WHEN S%NOTFOUND; --BREAK OUT OF LOOP WHEN NO ROWS ARE AVAILABLE
        DBMS_OUTPUT.PUT_LINE(' ID: '||SOME_ID||', NAME: '|| SOME_NAME);
    END LOOP;
    CLOSE S;
END;    

--STORED PROCEDURE TO FEED BEAR
--DOES THE BEAR KNOW ABOUT THE BEEHIVE?
--HOW MUCH ARE WE GOING TO FEED IT?
--NEED TO INCREASE BEAR WEIGHT AND DECREASE BEEHIVE WEIGHT

ALTER TABLE BEAR ADD CONSTRAINT CK_BEAR_WEIGHT_POSITIVE
CHECK (WEIGHT>0);
/

ALTER TABLE BEEHIVE ADD CONSTRAINT CK_BEEHIVE_WEIGHT_POSITIVE
CHECK (LBS_HONEY>0);
/

INSERT INTO BEAR_BEEHIVE VALUES (1000, 2);
INSERT INTO BEAR_BEEHIVE VALUES (53, 2);

--NOW, THE PROCEDURE
CREATE OR REPLACE PROCEDURE SP_FEED_BEAR(B_ID IN NUMBER, H_ID IN NUMBER, HONEY_AMT IN NUMBER, AMT_FED OUT NUMBER)
IS 
BB_EXIST INTEGER;
BEGIN 
    --CHECK THAT THIS BEAR IS CORRECTLY MATCHED TO THIS BEEHIVE
    SELECT COUNT( BB.BEAR_ID) INTO BB_EXIST 
    FROM BEAR_BEEHIVE BB
    WHERE BB.BEAR_ID = B_ID
    AND BB.BEEHIVE_ID = H_ID;
    -- DBMS_OUTPUT.PUT_LINE(BB_EXIST);
    IF BB_EXIST > 0 THEN 
        --DECREASE BEEHIVE WEIGHT
        UPDATE BEEHIVE SET LBS_HONEY = LBS_HONEY-HONEY_AMT
        WHERE BEEHIVE_ID = H_ID;
        --INCREASE BEARWEIGHT
        UPDATE BEAR SET WEIGHT = WEIGHT+HONEY_AMT
        WHERE BEAR_ID = b_ID;
        
        --SET THE RETURN AVLUE
        AMT_FED := HONEY_AMT;
    ELSE 
        SELECT * FROM VE_BEARS_PER_CAVE;

        END IF;    
        
        COMMIT;
        EXCEPTION
            WHEN OTHERS THEN 
            -- DBMS_OUTPUT.PUT_LINE('FAILED TO FEED BEAR');
            AMT_FED := 0;
            ROLLBACK;
END;
/
DECLARE 
AMT_FED NUMBER;
BEGIN
    SP_FEED_BEAR(53, 2, 100, AMT_FED);
    DBMS_OUTPUT.PUT_LINE('FED BEAR: ' || AMT_FED || 'POUNDS OF HONEY');
END;    

SELECT B.BEAR_ID, B.BEAR_NAME, B.WEIGHT, B.BIRTHDATE, C.CAVE_ID, C.CAVE_NAME, C.MAX_BEARS, BT.BEAR_TYPE_ID, BT.BEAR_TYPE_NAME
FROM BEAR B
INNER JOIN BEAR_TYPE BT
ON B.BEAR_TYPE_ID = BT.BEAR_TYPE_ID
INNER JOIN CAVE C
ON B.CAVE_ID = C.CAVE_ID
ORDER BY B.BEAR_ID;


ALTER TABLE EMPLOYEE 
ADD CONSTRAINT PK_EMPLOYEE
PRIMARY KEY (EMPLOYEEID);
/

ALTER TABLE REIMBURSEMENT 
ADD CONSTRAINT PK_REIMBURSEMENT
PRIMARY KEY (REIMBURSEMENT);
/

ALTER TABLE ACCOUNT 
ADD CONSTRAINT PK_ACCOUNT
PRIMARY KEY (ACCOUNT);
/

ALTER TABLE BEAR_BEEHIVE 
ADD CONSTRAINT FK_BEEHIVE_BEAR_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/

CREATE SEQUENCE SQ_BEAR_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_CAVE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR --SPECIFY WHICH DML OPERATION, BEOFRE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE --SPECIFY WHICH DML OPERATION, BEOFRE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE --SPECIFY WHICH DML OPERATION, BEOFRE/AFTER, AND WHICH TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/